package lang.ast;

import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short READ = 2;
		static public final short NUMERAL = 3;
		static public final short BOOLEAN = 4;
		static public final short RP = 5;
		static public final short GT = 6;
		static public final short LT = 7;
		static public final short GE = 8;
		static public final short LE = 9;
		static public final short EQ = 10;
		static public final short NE = 11;
		static public final short LP = 12;
		static public final short ADD = 13;
		static public final short SUB = 14;
		static public final short INT = 15;
		static public final short BOOL = 16;
		static public final short SEMI = 17;
		static public final short LB = 18;
		static public final short ASSIGN = 19;
		static public final short MUL = 20;
		static public final short DIV = 21;
		static public final short MOD = 22;
		static public final short PRINT = 23;
		static public final short WHILE = 24;
		static public final short IF = 25;
		static public final short RB = 26;
		static public final short RETURN = 27;
		static public final short COMMA = 28;
		static public final short ELSE = 29;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"READ",
			"NUMERAL",
			"BOOLEAN",
			"RP",
			"GT",
			"LT",
			"GE",
			"LE",
			"EQ",
			"NE",
			"LP",
			"ADD",
			"SUB",
			"INT",
			"BOOL",
			"SEMI",
			"LB",
			"ASSIGN",
			"MUL",
			"DIV",
			"MOD",
			"PRINT",
			"WHILE",
			"IF",
			"RB",
			"RETURN",
			"COMMA",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ozbcbiL5KKn$zlfWKiOsMpWfIM0cM6KgPqfz8A28WiYci5bSqD11HP4Z$u0OWV$C07JDH" +
		"8C0O20TE09a92OaoWPL$SLnP1PNDVS4LGZ$zttvdfUpEtfSRGD$dTS#x$d7lVVU##U#y0pW" +
		"bCHp76eGY3CGHnb60eRa0XxiULo1PXz2fqmMFeYLwu5hsHYpx8yw8cSZKM8ISbcjxVPDnkL" +
		"Gke3WgevTQyIgiwmghUPLNliwephUh3LdMkHQssQACisdYBDj6YtPocHTEK6ZoAKjHYB6wa" +
		"LupXWQWx9nd9sGbZ3l9n1thWNlMkeLUCCO4s$J00LHY9cp01at1Be5OVgFdzn1XkmpIhVZr" +
		"cMVLCpCQyGCGRxq0Cm#8MxnR20dIG7SWokLwvq3pZ5ScUtLh7PAszRGpNOJIwghrLRSGybu" +
		"tEU12Ty93y8Z#ZGix9J#YERkZBiZ$AMDwDEap55Do9UzZB0tW4ZyiFrETZ1dZ9Rlfv$EMpJ" +
		"G7di3$VLo5xZkgA0cFk6ndA4PPnNLLm5LNnY$MYRgGEJbhKrb#iZMhj$shT$khbrz8LXxyG" +
		"rsK6RMhKdPFcsObphIRsrMOljKqcEl2RxyHLaCKlghMQtq#C8PFVwt$HXr4FzkgDrrsDyHR" +
		"lDfnj8jmFl5olB37FM9BisQtL#DvD#zeUFCToECgWTSnpsHZ2zv3BzUVEPgufkt5NZGJAFb" +
		"p$4NeEioEgTqLtuMLMEh1a6Spba6pryraTJoQJTQJUqvrNNQl#3j98Tf9TPAksFQpsU2AtD" +
		"TZk3HP7o5$qjwbMJgh9JF8CcTs6VhQJtcGZcKT6aGLaFLbCdYDFQ6uJYQeV9a#I3MGLMMhf" +
		"#odoCdcQD90LP9F6Nl7bZIExoKgIHLudhsbiZzfdIHVrzv8NIAxMtoERrN#HnDJVJzQGIh9" +
		"FjGDg3$dkVz3dzsJHg7v2YwijLRkobVUvshNyJ4wgFNUfEMXkYnpjuoLjUqhr1hK5RUodiz" +
		"eYjJf$sAAsoPTRwVEN#$nZbdvNg7rUxPfBZ6EaFizQecsS3HgRc99Rt#mx6ttwh9Iy#VPxE" +
		"GsM#o$nZFoDv2KNoQ$oeq$vdNnF$f3lv6lvIhwKit96JikfPCP9SfHyGDwLj#HDEIG7vO3i" +
		"btqyoRsSFmdNexnFtZ5AaoaFouSitvQziaVudSedv6FoaJJACTabE#L2yZxVo1SilpN#vwf" +
		"zPieJflmqcNcSd2U$2TU$$EE#Q#xH3dThbv3PZMkuEzRIrjAw$nRggBlxV9nxP0dzGTHSYi" +
		"XWizCvF2CSxdOX4kOE62BWlmodHKhPLndxB6T#1VVYIjegQjKandYCTHjHngB6XisvEj1OZ" +
		"tpM#wPGe0mWXURqTNYAPf0mprAN38pu5nL7cnG=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_decl_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] func_decl_list = func_decl.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncDecl a = (FuncDecl) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [2] func_decl_list = func_decl_list.a func_decl.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final FuncDecl b = (FuncDecl) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [3] func_param_list = param.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Param a = (Param) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [4] func_param_list = func_param_list.a COMMA param.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Param b = (Param) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [5] func_expr_list = expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List(a);
				}
			},
			new Action() {	// [6] func_expr_list = func_expr_list.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [7] stmt_list = stmt.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [8] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [9] func_decl = type.t func_id_decl.a LP func_param_list.par RP block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final FuncIdDecl a = (FuncIdDecl) _symbol_a.value;
					final Symbol _symbol_par = _symbols[offset + 4];
					final List par = (List) _symbol_par.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					 return new FuncDecl(t, a, par, b);
				}
			},
			new Action() {	// [10] func_decl = type.t func_id_decl.a LP RP block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final FuncIdDecl a = (FuncIdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new FuncDecl(t, a, new List(), b);
				}
			},
			new Action() {	// [11] param = type.a id_decl.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Type a = (Type) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return new Param(a,b);
				}
			},
			Action.RETURN,	// [12] type = int_type
			Action.RETURN,	// [13] type = bool_type
			new Action() {	// [14] int_type = INT.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					 return new IntType(t);
				}
			},
			new Action() {	// [15] bool_type = BOOL.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					 return new BoolType(t);
				}
			},
			new Action() {	// [16] id_decl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(id);
				}
			},
			new Action() {	// [17] func_id_decl = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new FuncIdDecl(id);
				}
			},
			new Action() {	// [18] block = LB RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Block(new List());
				}
			},
			new Action() {	// [19] block = LB stmt_list.a RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
				}
			},
			new Action() {	// [20] opt_block = ELSE block.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Block a = (Block) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [21] opt_block = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			Action.RETURN,	// [22] stmt = while
			Action.RETURN,	// [23] stmt = if
			Action.RETURN,	// [24] stmt = return
			Action.RETURN,	// [25] stmt = assign
			Action.RETURN,	// [26] stmt = decl
			Action.RETURN,	// [27] stmt = print
			Action.RETURN,	// [28] stmt = decl_assign
			new Action() {	// [29] while = WHILE LP expr.a RP block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new WhileStmt(a,b);
				}
			},
			new Action() {	// [30] if = IF LP expr.a RP block.b opt_block.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final Opt c = (Opt) _symbol_c.value;
					 return new IfStmt(a,b,c);
				}
			},
			new Action() {	// [31] return = RETURN expr.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
				}
			},
			new Action() {	// [32] assign = id_use.a ASSIGN expr.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUseExpr a = (IdUseExpr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AssignStmt(a,b);
				}
			},
			new Action() {	// [33] decl = type.t id_decl.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return new DeclStmt(t, a);
				}
			},
			new Action() {	// [34] print = PRINT LP expr.a RP SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					 return new PrintStmt(a);
				}
			},
			new Action() {	// [35] decl_assign = type.t id_decl.a ASSIGN expr.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expr b = (Expr) _symbol_b.value;
					 return new DeclAssignStmt(t,a,b);
				}
			},
			Action.RETURN,	// [36] expr = add_expr
			new Action() {	// [37] expr = expr.a GT add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GT(a, b);
				}
			},
			new Action() {	// [38] expr = expr.a LT add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LT(a, b);
				}
			},
			new Action() {	// [39] expr = expr.a GE add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GE(a, b);
				}
			},
			new Action() {	// [40] expr = expr.a LE add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LE(a, b);
				}
			},
			new Action() {	// [41] expr = expr.a EQ add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new EQ(a, b);
				}
			},
			new Action() {	// [42] expr = expr.a NE add_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NE(a, b);
				}
			},
			Action.RETURN,	// [43] add_expr = mul_expr
			new Action() {	// [44] add_expr = add_expr.a ADD mul_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [45] add_expr = add_expr.a SUB mul_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [46] mul_expr = unary_expr
			new Action() {	// [47] mul_expr = mul_expr.a MUL unary_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [48] mul_expr = mul_expr.a DIV unary_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [49] mul_expr = mul_expr.a MOD unary_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			Action.RETURN,	// [50] unary_expr = primary_expr
			Action.RETURN,	// [51] primary_expr = literal
			Action.RETURN,	// [52] primary_expr = id_use
			Action.RETURN,	// [53] primary_expr = func_use
			Action.RETURN,	// [54] primary_expr = func_read
			Action.RETURN,	// [55] literal = integer_literal
			Action.RETURN,	// [56] literal = bool_literal
			new Action() {	// [57] integer_literal = NUMERAL.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					 return new IntLiteral(num);
				}
			},
			new Action() {	// [58] bool_literal = BOOLEAN.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol b = _symbols[offset + 1];
					 return new BoolLiteral(b);
				}
			},
			new Action() {	// [59] id_use = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new IdUseExpr(id);
				}
			},
			new Action() {	// [60] func_use = ID.a LP func_expr_list.b RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new FuncUseExpr(a, b);
				}
			},
			new Action() {	// [61] func_use = ID.a LP RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new FuncUseExpr(a, new List());
				}
			},
			new Action() {	// [62] func_read = READ LP RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new ReadFunc(new Opt());
				}
			},
			new Action() {	// [63] func_read = READ LP expr.a RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReadFunc(new Opt(a));
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
